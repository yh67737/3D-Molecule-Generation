import pickle
import torch
import numpy as np
import py3Dmol
from IPython.display import display
from collections import Counter
import os
from pathlib import Path
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# --- 配置和映射 ---

# 1. 原子类型映射
ATOM_MAP = ['H', 'C', 'N', 'O', 'F', 'Absorbing']
ATOM_COLORS = {'H': 'white', 'C': 'black', 'N': 'blue', 'O': 'red', 'F': 'green'}

# 2. 边/键类型 (用于.mol文件)
BOND_TYPE_MAP = {0: 1, 1: 2, 2: 3, 3: 4} # SINGLE, DOUBLE, TRIPLE, AROMATIC

# --- 帮助函数 ---

def get_naive_formula(atom_symbols):
    # (此函数与之前相同)
    if not atom_symbols: return "N/A"
    counts = Counter(atom_symbols)
    formula = ""
    if 'C' in counts:
        formula += f"C{counts['C'] if counts['C'] > 1 else ''}"; del counts['C']
    if 'H' in counts:
        formula += f"H{counts['H'] if counts['H'] > 1 else ''}"; del counts['H']
    for symbol in sorted(counts.keys()):
        formula += f"{symbol}{counts[symbol] if counts[symbol] > 1 else ''}"
    return formula

def save_molecule_as_mol(path, symbols, positions, edge_index, bond_types):
    """将单个分子结构保存为 V2000 .mol 文件格式。"""
    num_atoms = len(symbols)
    num_bonds = edge_index.shape[1]
    
    with open(path, 'w') as f:
        # 文件头
        f.write(f"{Path(path).stem}\n")
        f.write("  Generated by Script\n\n")
        
        # 统计行: num_atoms num_bonds ... V2000
        f.write(f"{num_atoms:3d}{num_bonds:3d}  0  0  0  0  0  0  0  0999 V2000\n")
        
        # 原子块
        for i in range(num_atoms):
            x, y, z = positions[i]
            symbol = symbols[i]
            f.write(f"{x:10.4f}{y:10.4f}{z:10.4f} {symbol:3s} 0  0  0  0  0  0  0  0  0  0  0  0\n")
            
        # 键块
        for i in range(num_bonds):
            u, v = edge_index[:, i]
            bond_type = BOND_TYPE_MAP.get(bond_types[i], 1) # 默认为单键
            # .mol 文件索引从 1 开始
            f.write(f"{u+1:3d}{v+1:3d}{bond_type:3d}  0  0  0  0\n")
            
        f.write("M  END\n")

def save_3d_image_matplotlib(path, symbols, positions, edge_index):
    """使用 Matplotlib 保存分子的3D视图为图片。"""
    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection='3d')
    ax.set_box_aspect([1, 1, 1]) # 保证 xyz 轴比例一致

    # 绘制原子
    for i in range(len(symbols)):
        x, y, z = positions[i]
        symbol = symbols[i]
        ax.scatter([x], [y], [z], c=ATOM_COLORS.get(symbol, 'gray'), s=150, edgecolors='black', depthshade=True)

    # 绘制键
    for i in range(edge_index.shape[1]):
        u, v = edge_index[:, i]
        pos_u = positions[u]
        pos_v = positions[v]
        ax.plot([pos_u[0], pos_v[0]], [pos_u[1], pos_v[1]], [pos_u[2], pos_v[2]], color='black', linewidth=2)
        
    # 美化视图
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    ax.set_axis_off()
    ax.view_init(elev=30, azim=30)
    
    plt.savefig(path, dpi=300, bbox_inches='tight', pad_inches=0.1)
    plt.close(fig)

# --- 主函数 ---

def visualize_and_save_molecules(pkl_path, image_dir, structure_dir):
    """
    主函数：读取 pkl, 可视化, 并保存图片和结构文件。
    """
    # 确保输出目录存在
    Path(image_dir).mkdir(parents=True, exist_ok=True)
    Path(structure_dir).mkdir(parents=True, exist_ok=True)

    print(f"[*] 正在从 '{pkl_path}' 读取数据...")
    try:
        with open(pkl_path, 'rb') as f:
            molecule_data_list = pickle.load(f)
    except FileNotFoundError:
        print(f"[!]错误：文件 '{pkl_path}' 未找到。请检查路径是否正确。")
        return
    
    print(f"[✓] 读取成功！共找到 {len(molecule_data_list)} 个分子。\n")

    for i, data in enumerate(molecule_data_list):
        print(f"--- 分子 {i+1} ---")

        # --- 数据提取和预处理 ---
        atom_features = data.x.cpu().numpy()
        atom_positions = data.pos.cpu().numpy()
        edge_index = data.edge_index.cpu().numpy()
        edge_attrs = data.edge_attr.cpu().numpy()
        in_ring_flags = data.pring_out.cpu().numpy().flatten()
        
        atom_types_idx = np.argmax(atom_features, axis=1)
        bond_types_idx = np.argmax(edge_attrs, axis=1)
        
        real_atom_mask = atom_types_idx < (len(ATOM_MAP) - 1)
        real_atom_indices = np.where(real_atom_mask)[0]

        if len(real_atom_indices) == 0:
            print("[!] 该数据对象中没有找到真实原子，跳过。\n")
            continue
            
        # 基于真实原子重新构建数据
        real_positions = atom_positions[real_atom_mask]
        real_atom_symbols = [ATOM_MAP[idx] for idx in atom_types_idx[real_atom_mask]]
        
        # 过滤边，并重新映射索引
        node_map = {int(old_idx): new_idx for new_idx, old_idx in enumerate(real_atom_indices)}
        valid_bonds_mask = np.array([u in node_map and v in node_map for u, v in edge_index.T])
        
        if not np.any(valid_bonds_mask):
             # 如果没有有效的键，创建一个空的 edge_index
            real_edge_index = np.empty((2, 0), dtype=int)
            real_bond_types_idx = np.empty((0,), dtype=int)
        else:
            filtered_edge_index = edge_index[:, valid_bonds_mask]
            real_edge_index = np.vectorize(node_map.get)(filtered_edge_index)
            real_bond_types_idx = bond_types_idx[valid_bonds_mask]

        # --- 打印基本信息 ---
        formula = get_naive_formula(real_atom_symbols)
        print(f"[*] 基本信息:")
        print(f"    - 原子总数: {len(real_atom_symbols)}")
        print(f"    - 预测的键的数量: {real_edge_index.shape[1]}")
        print(f"    - 预测的化学式: {formula}")
        
        # --- 保存文件 ---
        img_path = os.path.join(image_dir, f"molecule_{i+1}.png")
        mol_path = os.path.join(structure_dir, f"molecule_{i+1}.mol")
        
        save_3d_image_matplotlib(img_path, real_atom_symbols, real_positions, real_edge_index)
        save_molecule_as_mol(mol_path, real_atom_symbols, real_positions, real_edge_index, real_bond_types_idx)
        print(f"\n[*] 文件已保存:")
        print(f"    - 3D 图像: {img_path}")
        print(f"    - 结构文件: {mol_path}")

        # --- py3Dmol 交互式可视化 (Jupyter/Colab环境) ---
        print("\n[*] 交互式 3D 结构:")
        view = py3Dmol.view(width=400, height=300)
        mol_block = open(mol_path, 'r').read()
        view.addModel(mol_block, 'mol')
        view.setStyle({'stick': {}, 'sphere': {'scale': 0.25}})
        view.zoomTo()
        view.show()

        print("\n" + "="*50 + "\n")


if __name__ == '__main__':
    # --- 用户配置区 ---
    
    # 1. 输入文件
    model_name_stem = 'best_model'
    pkl_file_path = f'output/2025-08-23_02-23-39/generated_pyg/generated_molecules_from_{model_name_stem}.pkl'
    
    # 2. 输出目录
    # 将所有输出文件保存在一个与 pkl 文件相关的文件夹中
    output_parent_dir = Path(pkl_file_path).parent
    image_output_dir = os.path.join(output_parent_dir, 'images')
    structure_output_dir = os.path.join(output_parent_dir, 'structures')
    
    # 3. 运行主函数
    visualize_and_save_molecules(
        pkl_path=pkl_file_path,
        image_dir=image_output_dir,
        structure_dir=structure_output_dir
    )