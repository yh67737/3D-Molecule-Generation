import pickle
import torch
import numpy as np
import py3Dmol
from IPython.display import display
from collections import Counter
import os
from pathlib import Path
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# --- 配置和映射 ---

# 1. 原子类型映射
ATOM_MAP = ['H', 'C', 'N', 'O', 'F', 'Absorbing']
ATOM_COLORS = {'H': 'white', 'C': 'black', 'N': 'blue', 'O': 'red', 'F': 'green'}

# 2. 边/键类型 (用于.mol文件)
BOND_TYPE_MAP = {0: 1, 1: 2, 2: 3} # SINGLE, DOUBLE, TRIPLE
# <--- 修改开始 --->
# 3. 边/键的绘制样式 (用于matplotlib)
# 为单键、双键、三键定义不同的线宽
BOND_STYLE_MAP = {
    0: {'color': 'black', 'linewidth': 2.0},  # 单键
    1: {'color': 'black', 'linewidth': 4.0},  # 双键
    2: {'color': 'black', 'linewidth': 6.0},  # 三键
}
# <--- 修改结束 --->


# --- 帮助函数 ---

def get_naive_formula(atom_symbols):
    # (此函数与之前相同)
    if not atom_symbols: return "N/A"
    counts = Counter(atom_symbols)
    formula = ""
    if 'C' in counts:
        formula += f"C{counts['C'] if counts['C'] > 1 else ''}"; del counts['C']
    if 'H' in counts:
        formula += f"H{counts['H'] if counts['H'] > 1 else ''}"; del counts['H']
    for symbol in sorted(counts.keys()):
        formula += f"{symbol}{counts[symbol] if counts[symbol] > 1 else ''}"
    return formula

def save_molecule_as_mol(path, symbols, positions, edge_index, bond_types):
    """将单个分子结构保存为 V2000 .mol 文件格式。"""
    num_atoms = len(symbols)
    num_bonds = edge_index.shape[1]
    
    with open(path, 'w') as f:
        # 文件头
        f.write(f"{Path(path).stem}\n")
        f.write("  Generated by Script\n\n")
        
        # 统计行
        f.write(f"{num_atoms:3d}{num_bonds:3d}  0  0  0  0  0  0  0  0999 V2000\n")
        
        # 原子块
        for i in range(num_atoms):
            x, y, z = positions[i]
            symbol = symbols[i]
            f.write(f"{x:10.4f}{y:10.4f}{z:10.4f} {symbol:3s} 0  0  0  0  0  0  0  0  0  0  0  0\n")
            
        # 键块
        for i in range(num_bonds):
            u, v = edge_index[:, i]
            bond_type = BOND_TYPE_MAP.get(bond_types[i], 1)
            f.write(f"{u+1:3d}{v+1:3d}{bond_type:3d}  0  0  0  0\n")
            
        f.write("M  END\n")

# <--- 修改开始 --->
def save_3d_image_matplotlib(path, symbols, positions, edge_index, bond_types):
    """使用 Matplotlib 保存分子的3D视图为图片，并根据键类型绘制不同样式的键。"""
    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection='3d')
    ax.set_box_aspect([1, 1, 1])

    # 绘制原子
    for i in range(len(symbols)):
        x, y, z = positions[i]
        symbol = symbols[i]
        ax.scatter([x], [y], [z], c=ATOM_COLORS.get(symbol, 'gray'), s=200, edgecolors='black', depthshade=True, zorder=2)

    # 绘制键
    for i in range(edge_index.shape[1]):
        u, v = edge_index[:, i]
        bond_type = bond_types[i]
        
        # 获取该类型键的样式，如果未定义则使用默认样式
        style = BOND_STYLE_MAP.get(bond_type, {'color': 'gray', 'linewidth': 1.0})
        
        pos_u = positions[u]
        pos_v = positions[v]
        ax.plot([pos_u[0], pos_v[0]], [pos_u[1], pos_v[1]], [pos_u[2], pos_v[2]], **style, zorder=1)
        
    # 美化视图
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    ax.set_axis_off()
    ax.view_init(elev=30, azim=30)
    
    plt.savefig(path, dpi=300, bbox_inches='tight', pad_inches=0.1)
    plt.close(fig)
# <--- 修改结束 --->

# --- 主函数 ---

def visualize_and_save_molecules(pkl_path, image_dir, structure_dir):
    """
    主函数：读取 pkl, 可视化, 并保存图片和结构文件。
    """
    Path(image_dir).mkdir(parents=True, exist_ok=True)
    Path(structure_dir).mkdir(parents=True, exist_ok=True)

    print(f"[*] 正在从 '{pkl_path}' 读取数据...")
    try:
        with open(pkl_path, 'rb') as f:
            molecule_data_list = pickle.load(f)
    except FileNotFoundError:
        print(f"[!]错误：文件 '{pkl_path}' 未找到。请检查路径是否正确。")
        return
    
    print(f"[✓] 读取成功！共找到 {len(molecule_data_list)} 个分子。\n")

    for i, data in enumerate(molecule_data_list):
        print(f"--- 分子 {i+1} ---")

        atom_features = data.x.cpu().numpy()
        atom_positions = data.pos.cpu().numpy()
        edge_index = data.edge_index.cpu().numpy()
        edge_attrs = data.edge_attr.cpu().numpy()
        
        atom_types_idx = np.argmax(atom_features, axis=1)
        bond_types_idx = np.argmax(edge_attrs, axis=1)
        
        real_atom_mask = atom_types_idx < (len(ATOM_MAP) - 1)
        real_atom_indices = np.where(real_atom_mask)[0]

        if len(real_atom_indices) == 0:
            print("[!] 该数据对象中没有找到真实原子，跳过。\n")
            continue
            
        real_positions = atom_positions[real_atom_mask]
        real_atom_symbols = [ATOM_MAP[idx] for idx in atom_types_idx[real_atom_mask]]
        
        # --- 边和键的过滤与重新映射 ---
        node_map = {int(old_idx): new_idx for new_idx, old_idx in enumerate(real_atom_indices)}
        
        # 1. 创建一个mask，筛选出连接两个真实原子的边
        edge_connects_real_atoms_mask = np.array([u in node_map and v in node_map for u, v in edge_index.T])
        
        # <--- 修改开始 --->
        # 2. 创建另一个mask，筛选出预测为真实化学键的边 (排除了 "no bond" 类别)
        #    我们假设真实的键类型索引是 0, 1, 2, 3。
        has_bond_mask = bond_types_idx < len(BOND_TYPE_MAP)
        
        # 检查输入是否为 PyTorch 张量或 NumPy 数组
        is_torch_tensor = hasattr(edge_connects_real_atoms_mask, 'to')

        if is_torch_tensor:
            # --- PyTorch 张量的修复方案 ---
            # 显式地将两个掩码都转换为布尔类型
            edge_connects_real_atoms_mask_bool = edge_connects_real_atoms_mask.to(torch.bool)
            has_bond_mask_bool = has_bond_mask.to(torch.bool)
        else:
            # --- NumPy 数组的修复方案 ---
            # 显式地将两个掩码都转换为布尔类型
            edge_connects_real_atoms_mask_bool = edge_connects_real_atoms_mask.astype(bool)
            has_bond_mask_bool = has_bond_mask.astype(bool)
        
        # 3. 将两个mask合并，得到最终有效的边
        valid_bonds_mask = edge_connects_real_atoms_mask_bool & has_bond_mask_bool
        # <--- 修改结束 --->
        
        if not np.any(valid_bonds_mask):
            real_edge_index = np.empty((2, 0), dtype=int)
            real_bond_types_idx = np.empty((0,), dtype=int)
        else:
            filtered_edge_index = edge_index[:, valid_bonds_mask]
            real_edge_index = np.vectorize(node_map.get)(filtered_edge_index)
            real_bond_types_idx = bond_types_idx[valid_bonds_mask]

        # --- 打印信息与保存 ---
        formula = get_naive_formula(real_atom_symbols)
        print(f"[*] 基本信息:")
        print(f"    - 原子总数: {len(real_atom_symbols)}")
        print(f"    - 预测的键的数量: {real_edge_index.shape[1]}")
        print(f"    - 预测的化学式: {formula}")
        
        img_path = os.path.join(image_dir, f"molecule_{i+1}.png")
        mol_path = os.path.join(structure_dir, f"molecule_{i+1}.mol")
        
        # <--- 修改开始 --->
        # 将 real_bond_types_idx 传递给绘图函数
        save_3d_image_matplotlib(img_path, real_atom_symbols, real_positions, real_edge_index, real_bond_types_idx)
        # <--- 修改结束 --->
        save_molecule_as_mol(mol_path, real_atom_symbols, real_positions, real_edge_index, real_bond_types_idx)
        print(f"\n[*] 文件已保存:")
        print(f"    - 3D 图像: {img_path}")
        print(f"    - 结构文件: {mol_path}")

        # --- py3Dmol 可视化 ---
        print("\n[*] 交互式 3D 结构:")
        view = py3Dmol.view(width=400, height=300)
        mol_block = open(mol_path, 'r').read()
        view.addModel(mol_block, 'mol')
        view.setStyle({'stick': {}, 'sphere': {'scale': 0.25}})
        view.zoomTo()
        view.show()

        print("\n" + "="*50 + "\n")


if __name__ == '__main__':
    # --- 用户配置区 ---
    model_name_stem = 'best_model'
    pkl_file_path = f'output/2025-10-15_09-01-50/generated_pyg/generated_molecules_from_{model_name_stem}.pkl'
    
    output_parent_dir = Path(pkl_file_path).parent
    image_output_dir = os.path.join(output_parent_dir, 'images')
    structure_output_dir = os.path.join(output_parent_dir, 'structures')
    
    visualize_and_save_molecules(
        pkl_path=pkl_file_path,
        image_dir=image_output_dir,
        structure_dir=structure_output_dir
    )